%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                           Tarvo Reinpalu                               %%%%
%%%% Maximizing UITableView scrolling performance in Pairby iOS Application %%%%
%%%%                             20.02.2017                                 %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%
% General configuration %
%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{itk_thesis_eng}
\usepackage{cite}
\usepackage{parskip} % Define paragraph line-breaks
\usepackage{mathptmx} % Apply Times New Roman font
\usepackage[toc, xindy, style=list, nonumberlist]{glossaries}
\usepackage{url}
\graphicspath{{img/}}
\linespread{1.5}
\usepackage{hyperref}
\usepackage{tabularx} % Better tables (fill width)

\usepackage{titlesec} % Make new sections start with a 1.5cm margin
\newcommand{\sectionbreak}{\vspace*{1.5cm}}

\usepackage{minted} % Code coloring
\usepackage{xcolor}
\usemintedstyle{vs}
\definecolor{codebg}{gray}{0.96}
\setminted{
  bgcolor=codebg,
  tabsize=2,
  numbersep=8pt,
  xleftmargin=12pt,
  xrightmargin=12pt,
  fontsize=\scriptsize,
  breaklines=true,
  escapeinside=\#\#}

\begin{document}

%%%%%%%%%%%%%%%%%%%%
% Thesis constants %
%%%%%%%%%%%%%%%%%%%%
\begin{itkTitlePage}
\title{Maximizing UITableView scrolling performance in Pairby iOS application}
\paper{Diploma thesis}
\author{Tarvo Reinpalu}
\curriculum{IT systems development curriculum}
\supervisor{Gary Planthaber}
\consultant{N/A}
\end{itkTitlePage}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Pre-content chapters %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%
% Author declaration %
%%%%%%%%%%%%%%%%%%%%%%
\itkMakeAuthorDeclaration

%%%%%%%%%%%%%%%%%%%%%
% Table of contents %
%%%%%%%%%%%%%%%%%%%%%
\clearpage
\thispagestyle{empty}
\tableofcontents
\newpage



%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Content chapters %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\introduction{Introduction}
Verbal feedback from smartphone users, online studies regarding the priorities of mobile application users\cite{AppSpeedStudyHP}\cite{AppSpeedStudyApigee} and the author's personal preference all indicate that mobile applications' performance is important. This is not a recent trend. The expectation of having no input lag has been around as long as the technological devices that require user input have existed.\cite{NielsenUsabilityEngineering} Even the slightest delay (anything above 0.1s) is not considered instantaneous by users and anything above 1 second results in the user's flow of thought to be interrupted and focus to be lost.\cite{NielsenUsabilityEngineering} That is enough information to conclude that not only do the users expect a smooth and fast user experience, it is actually necessary to retain the user's attention.

Pairby's mobile applications are no exception when it comes to that good user experience requirement. Pairby, of which the author is a co-founder of, is a mobile dating service which has applications on both iOS and Android platforms. The thesis subject is directly derived from the author's interest in solving a performance issue in the iOS application.

\introductionSubsection{Description of the problem}
Pairby iOS application contains, among other views, a multitude of different vertically scrolling views, which can contain a theoretically unlimited amount of subviews. One of those vertically scrolling views is the message list view, which this thesis will focus on. The message list view's purpose is to render a list of messages using a \mintinline{swift}{UITableView} component, where each message could contain either text or images.

Pairby iOS application's first prototype version was scratched due to a massive performance issue in the message list view. Namely, scrolling up or down at a rapid speed in that view was so resource consuming on any older Apple device it froze the whole user interface. This behavior was deemed unacceptable by the Pairby team and development of that prototype was halted. It becamse apparent to the developer that something had been done wrong both in the development of the user interface and in the handling of the data in the model.

At the time of starting the thesis test project, the development of the new iOS application for Pairby had started, but a solution to the performance issue had not yet been found.

\introductionSubsection{Goal of the thesis}
The goal of the thesis was to analyze a number of different optimizations that can be done to the \mintinline{swift}{UITableView} component and its subviews (cells) in order to reduce the resource consumption on less powerful iOS devices and through that improve the responsiveness of the user interface. All optimizations were applied in a sequence, where the next one would complement the previous one, creating a more performant view after each optimization. The user interface was designed with the Pairby real-life application in mind: visually, the test project and the real life application share many similarities.

Each optimization had to go through a pre-defined programmatic scrolling test while different aspects of the device's were monitored. The monitoring resulted in large data sets about the frame rate, CPU usage and memory usage, which were then analyzed and combined into general data about the test. These generalized values were then compared against existing results and the optimization's effectiveness was decided based on that.

The expected end result was a \mintinline{swift}{UITableView} component that is performant even when the scroll speeds exceed the boundaries of realistic use cases.

%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Specifications % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Specifications}
The test project was meant to broadly mimic the user interface of the real-life iOS application of Pairby. This could only be possible if there were a number of requirements set to the project's test data and user interface.

\subsection{Test data requirements}
The test data contained 1000 message type objects. The data was stored in JSON format and saved to a file, which could then be loaded into the iOS test project.

\subsubsection*{Message type}
The type definition for the Message object.

\vskip.2in

\begin{table}[H]
  \caption{Message type definition}
  \begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    Property & Type & Required & Description \\
    \hline
    messageId & Integer & true & A unique identifier derived from a sequence starting at 0 with an increment of 1. \\
    direction & String & true & Can be either "in" or "out", representing the direction of the message relative to the user. \\
    message & String & false & Text message's text. Not present in media messages. \\
    mediaItems & String[] & false & Media message's media URLs. Not present in text messages. \\
    \hline
  \end{tabularx}
\end{table}

\subsubsection*{Text message requirements}
Text messages can vary in both width and height. Width is purely dependant on the length of the longest line of text in the message text. The height depends on the number of lines in the text. The number of lines in turn depends on whether the text is long enough to require text wrapping or contains line breaks.

To simulate real life scenarios, text messages of three different widths and heights were created. These test messages consisted of short single line messages, medium two line messages and wide three line messages. To guarantee similar data rendering across different devices and screen widths, line breaks were used to create multi-line messages. The other option would have required word-wrapping, which would have depended on the width of the screen on the device and not produced the same number of lines on across all devices.

\subsubsection*{Media message requirements}
In the Pairby real life application, media messages can contain up to 6 media items that can either be static images (JPG), animated images (GIF) or videos (MP4).

Inside the messages list view, however, the media items are restricted into two different formats: static and animated images. Videos are not included as videos, when displayed as a thumbnail inside a message view, instead, a static thumbnail image is used. This reduces the required different media types down to JPG and GIF formats.

To simplify and speed up the building of different benchmark views, the maximum number of media items in a message was reduced to 3, instead of 6. Therefore the number of media items inside a media message could be 1 to 3 (inclusive).

To simulate real conditions, all media should be loaded from Pairby servers through the network.

\subsection{Test data generation}
Test data for the project is generated in a separate script, which is written in JavaScript and executed in a Node.JS environment. The output of the script is a JSON file that contains an array of message type objects.

\subsubsection*{Message generation}
The number of messages to be generated is configurable and was set to 1000 for the purposes of this test project.

The type (text or media) of each message was decided using a semi-random probability technique: a random number from 0 to 1 was generated and compared against a configurable parameter called "media message probability". If the generated number was less than or equal to the "media message probability" parameter, the message type was set to be media message and therefore its "mediaItems" parameter was filled out. If the generated number happened to be larger than the previously defined parameter, then the message was set to be of text type and its "message" property was filled out.

The message ID was simply set to the sequence number in the running loop (which started at zero and ended at the number of generated messages minus 1). For the 1000 messages generated for the purpose of this test, the IDs ranged from 0 to 999 (inclusive).

Each message's direction was also defined through a random number generator and was set to have an equal chance of either being outbound or inbound. This process was similar to the way the message type was chosen: a random number between 0 and 1 was generated and it was compared against 0.5, if was less than or equal to it, "direction" property was set to out, otherwise it was set to "in".

\subsubsection*{Text message content generation}
As defined in the specifications, there are three different text messages, that are all different in height and width. The text for each three different types is static and would not not change. Selecting one of the three was random and each message type had an equal chance of being selected. A random whole number between 1 and 3 (inclusive) was generated, if it was 1, then the one line and shortest width message was chosen. If the generated number happened to be 2, then the two line medium width text was chosen. If the number was 3, then the three line and widest text was selected.

\subsubsection*{Media message content generation}
In order to properly mimic the real life scenarios in the message list view all media should be loaded from the Pairby media servers. This obviously ruled out the possibility of including the images locally with the iOS test project. The ability of uploading media to the Pairby media servers through the actual API was built to the data generator, which then returned the URLs to the uploaded files.

The sample media files consisted of 100 static images of JPG format and 10 animated images of GIF format. All of those images were uploaded to the Pairby media servers.

The number of media items to include with a specific media message was a random number between 1 and 3 (inclusive).

The URL or URLs that would represent the media items were chosen completely randomly and duplicates were not prevented. Therefore there could be media messages that contained the same item twice. Even though this would not be possible in the real life Pairby application, there was no direct reason to prevent it from happening either, for it should still work as expected.

\subsection{User interface requirements}
As stated in the introduction to this section, the user interface is meant to mimic Pairby iOS application's messaging user interface.

\subsubsection*{Common design elements}
Both the text and media message views should have rounded corners and a thin border of gray colour.

\subsubsection*{Text message}
The text message view should be able to handle line breaks (increase in height to display all lines). The background color for inbound and outbound messages should be different: teal for outbound, gray for inbound.

\subsubsection*{Media message}
Media message view stylings depend on the number of images they contain.

\paragraph*{1 media item}
A single media item message should display the image with a width and height of 180 points.

\paragraph*{2 media items}
A two media item message should display the images side by side, with the image widths and heights being 90 points.

\paragraph*{3 media items}
A three media item message should display the images side by side, with the image widths and heights being 90 points.

%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Measuring performance % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Measuring performance}
To be able to gather quantifiable information and not base comparison points on visual judgement, there needed to be a way to run equal and repeatable tests and gather statistics based on numbers from each test. This was achieved in two different parts: the creation of a repeatable test case and figuring out how to gather statistics from each case.

\subsection{Repeatable test case}
The repeatable test case's purpose was well defined from the start: it should simulate scrolling. And it should do it in a way that is exactly the same every time.

To achieve this, \mintinline{swift}{UITableView}'s \mintinline{swift}{setContentOffset(contentOffset, animated: true)} function was used along with a repeating \mintinline{swift}{Timer}. The timer fired every 0.3 seconds and forced the view to scroll, starting from the top, towards the bottom every cycle. The scrolling was purposefully not linear, every cycle would increase it by a certain amount, which depended on a fixed parameter and the amount currently scrolled. This would bring an increasing scroll speed factor into play, which serves the purpose of simulating a real user scrolling.

\subsection{Measuring test case performance}
The only metric behind measuring scrolling performance was framerate. Measuring the framerate with high accuracy and in a deterministic manner was the key to giving metrics to test case performance. In addition to measuring the framerate, it was decided to analyze how framerate is dependant on the resource usage, so memory and processor usage were also monitored.

Xcode is bundled with a Instruments tool, which also includes a Core Animation statistics monitor which displays the framerate of the application it attaches itself to.

The tool was configured to extract the current framerate of the scroll view application every 1/10th of a second. The framerate numbers that were reported back while the programmatic scrolling test was running were placed into a spreadsheet and analytics were calculated based on the reported information.

In addition to that, the tool was also configured to extract the memory and processor usage. Since precision in these metrics is not that important for our tests, the information sampling rate was set to once a second. The gathered information was also put into a spreadsheet and analytics were based on that.

\subsection{Analyzing gathered metrics}
In order to get a comprehensible view of the gathered data, the large sets of data had to be trimmed down to a small number of data points. For framerates, it was decided to use average and lowest framerate as the key indicators. For memory and processor usage, only averages were calculated.

This resulted with a list of the following metrics for each test:
\begin{itemize}
  \item Average framerate (FPS)
  \item Lowest framerate (FPS)
  \item Average CPU usage
  \item Average memory consumption
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Used third party libraries % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Used third party libraries}
Creating every aspect from scratch in the test project would have been to large of a task to cover in this thesis, therefore third-party solutions were used to simplify some tasks. The affected aspects were for example JSON parsing, image loading and caching, detailed logging and in-code constraint creation.

\subsection{JASON}
JASON is a faster JSON deserializer written in Swift.\cite{JASON} The sole purpose for this library in the test project is to turn the test data from JSON form into Swift objects. Even though deserialization of the JSON information could have been done using Swift's built in capabilities, JASON allows the same purpose to be achieved with much shorter and more readable code.

\subsection{SnapKit}
SnapKit is a DSL to make Auto Layout easy on both iOS and OS X.\cite{SnapKit} SnapKit is used extensively in the test project to create constraints in the code, rather than in the storyboard. Creating layout constraints in the code has many benefits over creating them in the storyboards. For example, it removes the system overhead brought in by the processing of storyboards. It also gives the engineer very precise control over each constraint and provides an overview of all constraints that exist and when they will be created. Storyboard only has the benefit of providing the user with a graphical interface in which to create those constraints.

\subsection{PINRemoteImage}
PINRemoteImage, also known as PINRemoteImageManager, is an image downloading, processing and caching manager.\cite{PINRemoteImage} PINRemoteImage is used for the exact three things brought out in the library's description: it downloads the images, allows them to be processed and then stored safely in a disk cache. All that with minimal effort from the library user. Downloading images would've been trivial with the Swift's built in tools as well, but processing and caching, not that easy. Processing the images is especially useful, since it allows to scale the image down if necessary, which in turn makes the image smaller in dimensions and the file smaller in size. The caching manager is also quite advanced and extremely useful because it provides the option to cache different versions of the same image, including the original one. The different versions are distinguished by a string key passed to the process function.

\subsection{XCGLogger}
XCGLogger is a debug log framework for use in Swift projects.\cite{XCGLogger} XCGLogger improves Swift's built-in logging mechanism by adding a lot of useful, yet optional, information about every log statement. For example, it displays the thread name on which the log statement was executed on, without forcing the engineer to explicitly print out the thread name. The exact same goes for function names, file names and line numbers. Its uses and benefits in the test project are the same as the examples brought out previously (such as the identification of threads).

\subsection{FLAnimatedImageView}
FLAnimatedImage is a performant animated GIF engine for iOS.\cite{FLAnimatedImageView} FLAnimatedImageView does what the iOS's built in \mintinline{swift}{UIImageView} can not: play GIFs. This library is very important to both the test project and the actual Pairby application for that reason.

%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Comparison points % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Comparison points}
In order to be able to compare performance changes in the test project, we need some starting points. It was decided to use a best case scenario and a worst case scenario for starting points. Each of the tests should be run with the exact same data set, including the best and worst case scenario ones.

\subsection{Best case scenario}
The best case scenario should have the perfect conditions for running the tests and display the maximum possible performance. To create the perfect conditions, media items were omitted from the equation and all UITableView cells were turned into text cells (built-in UITableViewCell class).

To achieve a text-only message list, all media messages were replaced at runtime with a string \mintinline{text}{Media message with id [#1]} where \mintinline{text}{#1} would become the ID of the message. Text messages were displayed as they would be normally.

From just a glance, it was obvious that the scrolling on this view was extremely smooth and most likely a constant 60 frames per second, which is the so called iOS golden standard.\cite{IntroducingAsyncDisplayKit}

Running the performance benchmarks yielded the following results:
% TODO

\subsection{Worst case scenario}
The worst case scenario should have the least possible amount of optimizations and not follow any common performance boosting patterns. The data set was the same as the one provided in the best case scenario one, but media items were not been omitted in this case. All messages were displayed as was specified in the user interface specifications.

To render both text and media message views, two different view classes that inherited from \mintinline{swift}{UITableViewCell} were created. One for displaying text messages, the second one for displaying media messages.

Scrolling in this view was noticeably slow and a lot of frames were dropped.

Running the performance benchmarks yielded the following result:
% TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Performance optimizations % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Performance optimizations}
Performance optimizations started by taking the code from the worst case scenario test case and applying the first optimization to it. The rest of the optimizations were then applied to one another in the same pattern.

\subsection{Reusing cells}
Cell reusing is one of the optimizations that was not necessarily easiest to implement, but was definitely the correct starting point, for this is something that requires fundamental changes to the way the views are handled.

\subsubsection{Theoretical benefits}
Reusing cells means that every time a new message enters the view, instead of creating a new instance of the cell class, an existing object created from that class is used. This will require the fundamental changes mentioned earlier: views will need to have the ability to re-adjust themselves depending on the type of message they're meant to display. Previously, views only needed to define their layout state once, upon initialization, and would no longer have to readjust themselves.

This is beneficial to scrolling performance because it removes the necessity to create new views every time a new message needs to be rendered. The system overhead from allocating memory for each subview and garbage collector having to clean up views that are no longer rendered adds up when the user is scrolling rapidly and will cause hiccups in the user interface.

\subsubsection{Performance improvements}
Cell reusing did yield an increase in the average frame rate, as expected, but the increase was not drastic.

% TODO Comparisons, analytics, graphs

\subsubsection{Code examples}
The \mintinline{swift}{UITableView} component has support for view recycling already built in, requiring very little effort from the software engineer. All the recyclable classes should be registered to the instance of the \mintinline{swift}{UITableView} class and they can be requested from the same instance later.

Below is an example on how to register cell classes to be reused in a specific UITableView instance.
\begin{listing}[H]
  \caption{Registering cells to be reused on a specific UITableView instance}
  \begin{minted}{swift}
    self._tableView.register(ReusingCells_TextCell.self, forCellReuseIdentifier: "ReusingCells_TextCell")
    self._tableView.register(ReusingCells_MediaCell.self, forCellReuseIdentifier: "ReusingCells_MediaCell")
  \end{minted}
\end{listing}

Below is an example on how to query and use recycled cells in the same UITableView instance.
\begin{listing}[H]
  \caption{Using recycled cells in the test project}
  \begin{minted}{swift}
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
      let message = self._messages[indexPath.row]
      let cellIdentifier = (message.mediaItems == nil) ? "ReusingCells_TextCell" : "ReusingCells_MediaCell"
      let cell = self._tableView.dequeueReusableCell(withIdentifier: cellIdentifier) as! ReusableCell
      cell.updateFromMessage(message: message)
      return cell
    }
  \end{minted}
\end{listing}

\subsection{Static views}

\subsection{Manual cell height calculations}

\subsection{Cell height caching}

\subsection{Optimizing image sizes}

\subsection{Rasterizing cell layers}

\subsection{Avoiding offscreen rendering}

\subsection{ASyncDisplayKit}

%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% End result comparisons % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{End result}
\subsection{Compared to the best case scenario}

\subsection{Compared to the worst case scenario}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% After-content sections %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%
% Figures %
%%%%%%%%%%%
\newpage
\phantomsection
\addcontentsline{toc}{section}{List of Figures}
\listoffigures

%%%%%%%%%%%%%%
% References %
%%%%%%%%%%%%%%
\newpage
\phantomsection
\addcontentsline{toc}{section}{References}
\bibliography{thesis}
\bibliographystyle{plain}

\end{document}
