%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                           Tarvo Reinpalu                               %%%%
%%%% Maximizing UITableView scrolling performance in Pairby iOS Application %%%%
%%%%                             20.02.2017                                 %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%
% General configuration %
%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{itk_thesis_eng}
\usepackage{cite}
\usepackage{parskip} % Define paragraph line-breaks
\usepackage{mathptmx} % Apply Times New Roman font
\usepackage[toc, xindy, style=list, nonumberlist]{glossaries}
\usepackage{url}
\graphicspath{{img/}}
\linespread{1.5}
\usepackage{hyperref}
\usepackage{tabularx} % Better tables (fill width)

\usepackage{titlesec} % Make new sections start with a 1.5cm margin
\newcommand{\sectionbreak}{\vspace*{1.5cm}}

\usepackage{minted} % Code coloring
\usepackage{xcolor}
\usemintedstyle{vs}
\definecolor{codebg}{gray}{0.96}
\setminted{
  bgcolor=codebg,
  tabsize=2,
  fontsize=\scriptsize,
  breaklines=true,
  escapeinside=\#\#}

\begin{document}

%%%%%%%%%%%%%%%%%%%%
% Thesis constants %
%%%%%%%%%%%%%%%%%%%%
\begin{itkTitlePage}
\title{Optimizing UITableView in the Pairby iOS application}
\paper{Diploma thesis}
\author{Tarvo Reinpalu}
\curriculum{IT systems development curriculum}
\supervisor{Gary Planthaber}
\consultant{N/A}
\end{itkTitlePage}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Pre-content chapters %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%
% Author declaration %
%%%%%%%%%%%%%%%%%%%%%%
\itkMakeAuthorDeclaration

%%%%%%%%%%%%%%%%%%%%%
% Table of contents %
%%%%%%%%%%%%%%%%%%%%%
\clearpage
\thispagestyle{empty}
\tableofcontents
\newpage



%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Content chapters %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction % % REVIEWED | T: + | G:   %
%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\introduction{Introduction}
Verbal feedback from smartphone users, online studies regarding the priorities of mobile application users\cite{AppSpeedStudyHP}\cite{AppSpeedStudyApigee} and the author's personal preference all indicate that mobile applications' performance is important. This is not a recent trend. The expectation of having no input lag has been around as long as the technological devices that require user input have existed.\cite{NielsenUsabilityEngineering} Even the slightest delay (anything above 0.1s) is not considered instantaneous by users and anything above 1 second results in the user's flow of thought to be interrupted and focus to be lost.\cite{NielsenUsabilityEngineering} That is enough information to conclude that not only do the users expect a smooth and fast user experience, it is actually necessary to retain the user's attention.

Pairby's mobile applications are no exception when it comes to that good user experience requirement. Pairby, of which the author is a co-founder of, is a mobile dating service which has applications on both iOS and Android platforms. The thesis subject is directly derived from the author's interest in solving a performance issue in the iOS application.

\introductionSubsection{Description of the problem}
Pairby iOS application contains, among other views, a multitude of different vertically scrolling views, which can contain a theoretically unlimited amount of subviews. One of those vertically scrolling views is the message list view, which this thesis will focus on. The message list view's purpose is to render a list of messages using a \mintinline{swift}{UITableView} component, in which each message could contain either text or images.

Pairby iOS application's first prototype version was scratched due to a massive performance issue in the message list view. Namely, scrolling up or down at a rapid speed in that view was so resource consuming on any older Apple device it froze the whole user interface. This behavior was deemed unacceptable by the Pairby team and development of that prototype was halted. It became apparent to the developer that something fundamental had been done wrong both in the development of the user interface and in the handling of the data in the model.

At the time of starting the thesis test project, the development of the new iOS application for Pairby had started, but a solution to the performance issue had not yet been found.

\introductionSubsection{Goal of the thesis}
The goal of the thesis is to analyze a number of different optimizations that can be done to the \mintinline{swift}{UITableView} component and its subviews (cells) in order to reduce the resource consumption on less powerful iOS devices and through that improve the responsiveness of the user interface. All optimizations were applied in a sequence, where the next one would complement the previous one, creating a more performant view after each optimization. The user interface was designed with the Pairby real-life application in mind: visually, the test project and the real life application share many similarities.

Each optimization had to go through a pre-defined programmatic scrolling test while different aspects of the device's were monitored. The monitoring resulted in large data sets about the frame rate, CPU usage and memory usage, which were then analyzed and combined into general data about the test. These generalized values were then compared against existing results and the optimization's effectiveness was decided based on that.

The expected end result was a \mintinline{swift}{UITableView} component that is performant even when the scroll behavior exceeds the boundaries of realistic use cases.

%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Specifications % % REVIEWED | T: + | G:   %
%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Specifications}
The test project was meant to broadly mimic the user interface of the real-life iOS application of Pairby. This could only be possible if there were a number of requirements set to the project's test data and user interface.

\subsection{Test data requirements}
The test data contained 500 message type objects. The data was stored in JSON format and saved to a file which could then be loaded into the iOS test project using the XCode assets interface.

\subsubsection*{Message type}
The type definition for the Message object.

\vskip.2in

\begin{table}[H]
  \caption{Message type definition}
  \begin{tabularx}{\textwidth}{| l | l | l | X |}
    \hline
    Property & Type & Required & Description \\
    \hline
    messageId & Integer & true & A unique identifier generated from a sequence starting at 0 with an increment of 1. \\
    direction & String & true & Can be either "in" or "out", representing the direction of the message relative to the current user. \\
    message & String & false & Text message's text. Not present in media messages. \\
    mediaItems & String[] & false & Media message's media URLs. Not present in text messages. \\
    \hline
  \end{tabularx}
\end{table}

\subsubsection*{Text message requirements}
Text messages can vary in both width and height. Width is dependant on both the length of the longest line of text in the message text and the screen width. The height depends on the number of lines in the text. The number of lines in turn depends on the screen width and whether the text is long enough to require text wrapping or contains line breaks.

To simulate real life scenarios, text messages of three different widths and heights were created. These test messages consisted of horizontally slim single line messages, medium width two line messages and wide three line messages. To guarantee similar data rendering across different devices and screen widths, line breaks were used to create multi-line messages. The other option would have required word-wrapping, which would have depended on the width of the screen on the device and not produced the same number of lines on across all devices.

\subsubsection*{Media message requirements}
In the Pairby real life application, media messages can contain up to 6 media items that can either be static images (JPG), animated images (GIF) or videos (MP4).

Inside the messages list view, however, the media items are restricted into two different formats: static and animated images. Video thumbnails, which are the displayed in the message list view, are still static images. This reduces the required different media types down to static and animated images.

To simplify and speed up the building of different benchmark views, the maximum number of media items in a message was reduced to 3, instead of 6. Therefore the number of media items inside a media message could be 1 to 3 (inclusive).

To simulate real conditions, all media should be loaded from Pairby servers through the network. This also raised the requirements of running all the tests on the same network, while closely monitoring the network usage (all the tests had to be run under similar network load, to not increase the number of different factors that could affect the results).

\subsection{Test data generation}
Test data for the project was generated in a separate script, which is written in JavaScript and executed in a Node.JS environment. The output of the script was a JSON file that contained an array of message type objects.

\subsubsection*{Message generation}
The number of messages to be generated was configurable and was set to 500 for the purposes of this test project.

The type (text or media) of each message was decided using a semi-random probability technique: a random number from 0 to 1 was generated and compared against a configurable parameter called "media message probability". If the generated number was less than or equal to the "media message probability" parameter, the message type was set to be media message and therefore its "mediaItems" parameter was filled out. If the generated number happened to be larger than the previously defined parameter, then the message was set to be of text type and its "message" property was filled out. The test dataset was generated with the media message probability set to 0.25 (25\%).

The message ID was simply set to the sequence number in the running loop (which started at zero and ended at the number of generated messages minus 1). For the 500 messages generated for the purpose of this test, the IDs ranged from 0 to 499 (inclusive).

Each message's direction was also defined through a random number generator and was set to have an equal chance of either being outbound or inbound. This process was similar to the way the message type was chosen: a random number between 0 and 1 was generated and it was compared against 0.5, if was less than or equal to 0.5, "direction" property was set to out, otherwise it was set to "in". This would in theory mean that half of the messages would be outbound and the other half inbound, but not in a pre-determined order.

\subsubsection*{Text message content generation}
As defined in the specifications, there were three different text messages, all of which were different in height and width. The text for each three different types was static (pre-defined). Selecting one of the three different texts (which would determine both the width and height) was random and each message type had an equal chance of being selected. A random whole number between 1 and 3 (inclusive) was generated, if it was 1, then the short one line message was chosen. If the generated number was 2, then the two line medium width text was chosen. If the number was 3, then the three line and widest text was selected.

\subsubsection*{Media message content generation}
In order to properly mimic the real life scenarios in the message list view all media had to be loaded from the Pairby media servers. The ability of uploading media to the Pairby media servers through the public Pairby API was built to the data generator, which then returned the URLs to the uploaded files.

The sample media files consisted of 100 static images of JPG format and 10 animated images of GIF format. All of those images were uploaded to the Pairby media servers.

The number of media items to include with a specific media message was a random number between 1 and 3 (inclusive).

The URL or URLs that would represent the media items were chosen randomly and duplicates were not prevented. Therefore there could be media messages that contained the same media item multiple times. Even though this would not be possible in the real life Pairby application, there was no direct reason to prevent it from happening either, for it should still work as expected and not affect the performance that much.

\subsection{User interface requirements}
As stated in the introduction to this section, the user interface was meant to mimic Pairby iOS application's messaging user interface.

\subsubsection*{Common design elements}
Both the text and media message views had to have rounded corners with a radius of 15 points and a border of gray colour (\mintinline{apacheconf}{#ECEFF1}) with a width of 1 point.

\subsubsection*{Text message}
The text message view had to be able to handle line breaks (increase in height to display all lines). The background color for inbound and outbound messages should be different: teal (\mintinline{apacheconf}{#4DB6AC}) for outbound, gray (\mintinline{apacheconf}{#ECEFF1}) for inbound.

\subsubsection*{Media message}
Media message view stylings were dependant on the number of images they contain, as is the case in the real-life Pairby iOS application.

\paragraph*{1 media item}
A single media item message displayed the image with a width and height of 180 points.

\paragraph*{2 media items}
A two media item message displayed the images side by side, with the image widths and heights being 90 points. The gap between the media items was 5 points.

\paragraph*{3 media items}
A three media item message displayed the images side by side, with the image widths and heights being 90 points. The gap between the media items was 5 points.

%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Measuring performance % % REVIEWED | T: + | G:   %
%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Measuring performance}
To gather quantifiable information and not base comparison points on visual judgement, there needed to be a way to run reproducible tests and gather number based statistics from each test. This was achieved in two different parts: the creation of a repeatable test case (programmatic scrolling) and using different kinds of software to retrieve and save information about the system.

\subsection{Repeatable test case}
The repeatable test case's purpose was to simulate scrolling and do it in the exact same way every time the test is executed.

To achieve this, \mintinline{swift}{UITableView}'s \mintinline{swift}{setContentOffset(contentOffset, animated: true)} function was used along with a repeating \mintinline{swift}{Timer}. The \mintinline{swift}{Timer} fired every 0.4 seconds and forced the view to scroll, starting from the top, towards the bottom. The scrolling was purposefully not linear: starting from 100 points, every time the timer fired and the view was scrolled, the scroll amount increased by 30 points. This means that the first time the timer fired, the \mintinline{swift}{setContentOffset(contentOffset, animated: true)} was fired with a 100 point increase in the vertical content offset. The next time, the increase was 130 points and after that, 160 points.

\subsection{Measuring test case performance}
A multitude of metrics were monitored to get a good overview of the performance and efficiency of the \mintinline{swift}{UITableView}. In addition to measuring frame rates and scroll test durations, the system resource usages were monitored. The purpose of that was to reveal if and how the performance is dependant on the system's resource usage. The monitored resources were processor (CPU), graphics processor (GPU) and memory (RAM) usage.

Measuring frame rates was programmatic and handled by a custom implementation of the FPSCounter\cite{FPSCounterGithub} library. The scroll test duration was also measured programmatically.

In addition to just measuring frame rate, a metric called frame rate stability was introduced. The simplified definition for that is "time spent within 20\% of the average frame rate". In the background, it was calculated as the percentage of measured frame rate points that were within 20\% of the average frame rate. The difference is that this might not directly translate into time spent in the stable zone, as frame rate measurements were taken at a 0.5 second interval.

The rest of the metrics, namely CPU, GPU and RAM usage were measured using a third-party software called GameBench\cite{GameBenchHome}. The software required very little setup and offered very few configuration options. All that was needed was to start the monitoring process and then end it when the test was finished and it would display the measured data in an exportable form. The data included the three data set points mentioned earlier.

\subsection{Analyzing gathered metrics}
In order to get a comprehensible overview of the gathered data, the large sets of data had to be trimmed down to a small number of data points. For frame rates, it was decided to use average frame rates and frame rate stability. For processor, graphics processor and memory usage, only averages were calculated.

This resulted with a list of the following measurement points for each test:
\begin{itemize}
  \item Duration (seconds)
  \item Average frame rate
  \item Frame rate stability
  \item Average processor usage
  \item Average graphics processor usage
  \item Average memory usage
\end{itemize}

\subsection{Test device}
The tests were run on a iPod Touch 5G, as it is a good example of a low-powered device. The 5th generation iPod touch has a retina display (resolution 1136x640)\cite{AppleIPodTouch5G} while still having a very weak processor (dual core Apple A5 underclocked to 800 MHz)\cite{MacObserverUnderclock}. All of this means all the performance optimizations would have a strong effect that is easy to detect in the measured data.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Used third party libraries % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Used third party libraries}
Creating every aspect from scratch in the test project would have been to large of a task to cover in this thesis, therefore third-party solutions were used to simplify some tasks. The affected aspects were for example JSON parsing, image loading and caching, detailed logging and in-code constraint creation.

\subsection{JASON}
JASON is a faster JSON deserializer written in Swift.\cite{JASON} The sole purpose for this library in the test project is to turn the test data from JSON form into Swift objects. Even though deserialization of the JSON information could have been done using Swift's built in capabilities, JASON allows the same purpose to be achieved with much shorter and more readable code.

\subsection{SnapKit}
SnapKit is a DSL to make Auto Layout easy on both iOS and OS X.\cite{SnapKit} SnapKit is used extensively in the test project to create constraints in the code, rather than in the storyboard. Creating layout constraints in the code has many benefits over creating them in the storyboards. For example, it removes the system overhead brought in by the processing of storyboards. It also gives the engineer very precise control over each constraint and provides an overview of all constraints that exist and when they will be created. Storyboard only has the benefit of providing the user with a graphical interface in which to create those constraints.

\subsection{PINRemoteImage}
PINRemoteImage, also known as PINRemoteImageManager, is an image downloading, processing and caching manager.\cite{PINRemoteImage} PINRemoteImage is used for the exact three things brought out in the library's description: it downloads the images, allows them to be processed and then stored safely in a disk cache. All that with minimal effort from the library user. Downloading images would've been trivial with the Swift's built in tools as well, but processing and caching, not that easy. Processing the images is especially useful, since it allows to scale the image down if necessary, which in turn makes the image smaller in dimensions and the file smaller in size. The caching manager is also quite advanced and extremely useful because it provides the option to cache different versions of the same image, including the original one. The different versions are distinguished by a string key passed to the process function.

\subsection{XCGLogger}
XCGLogger is a debug log framework for use in Swift projects.\cite{XCGLogger} XCGLogger improves Swift's built-in logging mechanism by adding a lot of useful, yet optional, information about every log statement. For example, it displays the thread name on which the log statement was executed on, without forcing the engineer to explicitly print out the thread name. The exact same goes for function names, file names and line numbers. Its uses and benefits in the test project are the same as the examples brought out previously (such as the identification of threads).

\subsection{FLAnimatedImageView}
FLAnimatedImage is a performant animated GIF engine for iOS.\cite{FLAnimatedImageView} FLAnimatedImageView does what the iOS's built in \mintinline{swift}{UIImageView} can not: play GIFs. This library is very important to both the test project and the actual Pairby application for that reason.

\subsection{FPSCounter}
FPSCounter is a small library to measure the frame rate of an iOS Application.\cite{FPSCounterGithub} It was used for that same purpose in the test project. The data gathered by it was used to analyze the performance of each optimization method (and/or test case).

%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Comparison points % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Comparison points}
In order to be able to compare performance changes in the test project, we need some starting points. It was decided to use a best case scenario and a worst case scenario for starting points. Each of the tests should be run with the exact same data set, including the best and worst case scenario ones.

\subsection{Best case scenario}
The best case scenario should have the perfect conditions for running the tests and display the maximum possible performance. To create the perfect conditions, media items were omitted from the equation and all UITableView cells were turned into text cells (built-in UITableViewCell class).

To achieve a text-only message list, all media messages were replaced at runtime with a string \mintinline{text}{Media message with id [#1]} where \mintinline{text}{#1} would become the ID of the message. Text messages were displayed as they would be normally.

From just a glance, it was obvious that the scrolling on this view was extremely smooth and most likely a constant 60 frames per second, which is the so called iOS golden standard.\cite{IntroducingAsyncDisplayKit}

Running the performance benchmarks yielded the following results:
% TODO

\subsection{Worst case scenario}
The worst case scenario should have the least possible amount of optimizations and not follow any common performance boosting patterns. The data set was the same as the one provided in the best case scenario one, but media items were not been omitted in this case. All messages were displayed as was specified in the user interface specifications.

To render both text and media message views, two different view classes that inherited from \mintinline{swift}{UITableViewCell} were created. One for displaying text messages, the second one for displaying media messages.

Scrolling in this view was noticeably slow and a lot of frames were dropped.

Running the performance benchmarks yielded the following result:
% TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Performance optimizations % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Performance optimizations}
Performance optimizations started by taking the code from the worst case scenario test case and applying the first optimization to it. The rest of the optimizations were then applied to one another in the same pattern.

%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Reusing cells % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reusing cells}
Cell reusing is one of the optimizations that was not necessarily easiest to implement, but was definitely the correct starting point, for this is something that requires fundamental changes to the way the views are handled.

\subsubsection*{Theoretical benefits}
Reusing cells means that every time a new message enters the view, instead of creating a new instance of the cell class, an existing object created from that class is used. This will require the fundamental changes mentioned earlier: views will need to have the ability to re-adjust themselves depending on the type of message they're meant to display. Previously, views only needed to define their layout state once, upon initialization, and would no longer have to readjust themselves.

This is beneficial to scrolling performance because it removes the necessity to create new views every time a new message needs to be rendered. The system overhead from allocating memory for each subview and garbage collector having to clean up views that are no longer rendered adds up when the user is scrolling rapidly and will cause hiccups in the user interface.

\subsubsection*{Performance changes}
Cell reusing did yield an increase in the average frame rate, as expected, but the increase was not drastic.

% TODO Comparisons, analytics, graphs

\subsubsection*{Code examples}
The \mintinline{swift}{UITableView} component has support for view recycling already built in, requiring very little effort from the software engineer. All the recyclable classes should be registered to the instance of the \mintinline{swift}{UITableView} class and they can be requested from the same instance later.

Below is an example on how to register cell classes to be reused in a specific UITableView instance.
\begin{listing}[H]
  \caption{Registering cells to be reused on a specific UITableView instance}
  \begin{minted}{swift}
    self._tableView.register(ReusingCells_TextCell.self, forCellReuseIdentifier: "ReusingCells_TextCell")
    self._tableView.register(ReusingCells_MediaCell.self, forCellReuseIdentifier: "ReusingCells_MediaCell")
  \end{minted}
\end{listing}

Below is an example on how to query and use recycled cells in the same UITableView instance.
\begin{listing}[H]
  \caption{Using recycled cells in the test project}
  \begin{minted}{swift}
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
      let message = self._messages[indexPath.row]
      let cellIdentifier = (message.mediaItems == nil) ? "ReusingCells_TextCell" : "ReusingCells_MediaCell"
      let cell = self._tableView.dequeueReusableCell(withIdentifier: cellIdentifier) as! ReusableCell
      cell.updateFromMessage(message: message)
      return cell
    }
  \end{minted}
\end{listing}

%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Static layouts % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Making cell views' layout static}
Changing views by creating and removing both views and constraints was the next obvious performance degrader. The solution to this problem was simple: create specific views for each different view and only change their content. This meant that instead of the two different table cell views that existed at that point, there would be eight different views. These new views would technically have a static layout.

List of necessary cell views to make views with a static layout possible:
\begin{itemize}
  \item Inbound text message view
  \item Outbound text message view
  \item Inbound media item view (1 media item)
  \item Outbound media item view (1 media items)
  \item Inbound media item view (2 media items)
  \item Outbound media item view (2 media items)
  \item Inbound media item view (3 media items)
  \item Outbound media item view (3 media items)
\end{itemize}

\subsubsection*{Theoretical benefits}
The most straightforward benefit is the fact that this solution would remove the overhead of adding and removing of both subviews and their constraints. This is similar to the previous optimization, but on a smaller scale. In this case, the inner views were being removed and recreated every time a cell needed to be displayed. 

\subsubsection*{Performance changes}
Making the views' layout static yielded a more significant increase in the scroll performance compared to the cell reusing optimization. The increase in performance was expected.

% TODO Comparisons, analytics, graphs

\subsubsection*{Code examples}
This also changed the code for reusing the cells. After re-working the cell views, 8 different views needed to be registered to be recycled and that in turn made the logic of querying reusable cells a bit more difficult.

Below is the new code where the 8 new views are registered in the main \mintinline{swift}{UITableView} instance:
\begin{listing}[H]
  \caption{Using recycled cells in the test project}
  \begin{minted}{swift}
    self._tableView.register(StaticCells_TextCell_In.self, forCellReuseIdentifier: "StaticCells_TextCell_In")
    self._tableView.register(StaticCells_TextCell_Out.self, forCellReuseIdentifier: "StaticCells_TextCell_Out")
    self._tableView.register(StaticCells_MediaCell_1_In.self, forCellReuseIdentifier: "StaticCells_MediaCell_1_In")
    self._tableView.register(StaticCells_MediaCell_1_Out.self, forCellReuseIdentifier: "StaticCells_MediaCell_1_Out")
    self._tableView.register(StaticCells_MediaCell_2_In.self, forCellReuseIdentifier: "StaticCells_MediaCell_2_In")
    self._tableView.register(StaticCells_MediaCell_2_Out.self, forCellReuseIdentifier: "StaticCells_MediaCell_2_Out")
    self._tableView.register(StaticCells_MediaCell_3_In.self, forCellReuseIdentifier: "StaticCells_MediaCell_3_In")
    self._tableView.register(StaticCells_MediaCell_3_Out.self, forCellReuseIdentifier: "StaticCells_MediaCell_3_Out")
  \end{minted}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Manual cell height calculations % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Manual cell height calculations}\label{subsection:ManualCellHeightCalculations}
So far, the cell height calculations had been done automatically. This was possible due to the \mintinline{swift}{UITableView} instance's property \mintinline{swift}{rowHeight} being set to \mintinline{swift}{UITableViewAutomaticDimension}. According to a multitude of sources, these automatic calculations are often slow and it's sensible to override them with manual calculations that will do the bare minimum.\cite{PerfectSmoothScrollingInUITableViews}\cite{HowToMakeDynamicTableViewCellHeight}

\subsubsection*{Theoretical benefits}
Doing the cell height calculations manually using optimized calculations improves the performance when scrolling at high speeds. When doing manual calculations, it's trivial to optimize the calculations for the type of cells the application should be able to render. For example, media cells have a fixed height and calculations are actually not necessary in that case.

\subsubsection*{Performance changes}
Manual cell height calculations improved the performance of rapid scrolling.

% TODO Analysis, tests, graphs

\subsubsection*{Code examples}
The cell height calculations overwriting has to occur in the function displayed below.
\begin{listing}[H]
  \caption{Overwriting cell height calculations}
  \begin{minted}{swift}
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
      return UITableViewAutomaticDimension
    }
  \end{minted}
\end{listing}

Calculating the height for media item cells was trivial since they have a fixed height and fixed vertical margins. Below is an example on how the height for media item cells was calculated.
\begin{listing}[H]
  \caption{Calculating media cell's height}
  \begin{minted}{swift}
    let message = self._messages[indexPath.row]
    if let mediaItems = message.mediaItems {
      let baseHeight = (mediaItems.count == 1) ? Pairby.MessageUI.HEIGHT_MEDIA_ONE : Pairby.MessageUI.HEIGHT_MEDIA_MULTIPLE
      let verticalMarginsSum = (2 * Pairby.MessageUI.MARGIN_VERTICAL_WRAP)
      return (baseHeight + verticalMarginsSum)
    }
  \end{minted}
\end{listing}

Calculating the height for text cells was more difficult as the text height could vary depending on the number of lines the text would require. The number of lines in turn was dependant on the length of the text and the screen width of the device. Below is an example on how to calculate the height for the text message cell from the text.
\begin{listing}[H]
  \caption{Calculating text cell's height}
  \begin{minted}{swift}
    let maximumWidth = (self._tableView.frame.size.width - (2 * Pairby.MessageUI.MARGIN_HORIZONTAL) - Pairby.MessageUI.MARGIN_HORIZONTAL_WRAP_DYNAMIC - Pairby.MessageUI.MARGIN_HORIZONTAL_WRAP_FIXED)
    let verticalMarginsSum = (2 * Pairby.MessageUI.MARGIN_VERTICAL + 2 * Pairby.MessageUI.MARGIN_VERTICAL_WRAP)
    let baseHeight = ceil(message.message!.heightWithConstrainedWidth(width: maximumWidth, font: Pairby.MessageUI.TEXT_FONT))
    return (baseHeight + verticalMarginsSum)
  \end{minted}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Cell height caching % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Cell height caching}
The next step after the previous optimizations of doing calculations manually was to cache the calculation results in memory. To make caching possible, another property had to be added to the Message object, called cachedHeight of CGFloat type.

\subsubsection*{Theoretical benefits}
Even though this would not change anything the first time the user scrolls the messages list, it would improve the speed of scrolling the next time they need to render the same cells again, since the calculation can be avoided.

\subsubsection*{Performance changes}
As expected, the scroll performance on the first time the user scrolls showed no change. The following scroll benchmarks displayed an increase in performance, as the height calculations were ignored.

\subsubsection*{Code examples}
The cache was a simple Dictionary where the key was the message's row index and the value was its height as a CGFloat type. Below is an example of the whole cycle of caching and using the cache. The calculations have been omitted from this code, they can be seen in section \ref{subsection:ManualCellHeightCalculations}. 
\begin{listing}[H]
  \caption{Caching and using cached height}
  \begin{minted}{swift}
    private var _heightCache: [Int: CGFloat] = [:]
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        if let height = self._heightCache[indexPath.row] { return height }
        // else do the height calculations
        self._heightCache[indexPath.row] = (Height + HeightAdd)
        return self._heightCache[indexPath.row]!
    }
  \end{minted}
\end{listing}


%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Optimizing image sizes % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Optimizing image sizes}
The message threads can contain a large number of media items. The test data was generated with this in mind and it also contains a large number of media - both animated and static images. This raised the question: is there anything that can be done to optimize for the large number of images?

Since PINRemoteImage already enabled the option to do image processing and caching of the processed images, it was decided to try and optimize the image sizes for the screen of the device they're being rendered on and the cell size. This means that when the images reach the view, they're already the exact size they should be and should not need any further processing (either up- or downscaling).

However, it should be noted that this processing can only occur for static images. Processing animated images (GIFs) was too difficult to do and would require a lot of processing power, which would not be beneficial enough. Another downside to processed GIFs is the fact that multiple versions of the same GIF would be kept in he disk cache and due to their size, this would lead to a lot of the limited sized disk cache being used for only a few GIFs.

\subsubsection*{Theoretical benefits}
If the static images would no longer need any up- or downscaling in terms of processing, this should theoretically improve the rendering times of the media cells.

\subsubsection*{Performance changes}
As expected, the performace improved slightly.

% TODO Graphs, analysis, whatevs

\subsubsection*{Code examples}

%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Layer rasterization % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rasterization of cell layers}
Rasterization in the iOS view rendering context means turning the view into a more efficiently renderable and cachable bitmap. Layer rasterization is a built in technique to the \mintinline{swift}{CALayer} part of the views.

\subsubsection*{Theoretical benefits}
All the views expect the ones containing animated images are static once rendered and will not change. This is one of the requirements to reap benefits from layer rasterization. Rasterization process does consume resources at first, but once done, the view will be handled much more efficiently by the rendering engine due to the fact that the GPU can use the cached bitmap instead of re-drawing the view.\cite{MovingPixelsOntoTheScreen}

\subsubsection*{Performance changes}
Performance did improve.

\subsubsection*{Code examples}
In order to enable rasterization of the views, only two lines of code need to be written. Below is the example of the two lines of code. The first one enabled rasterization and the second one tells the rasterization mechanism to use a certain scale to compensate for the fact that some devices are using retina screens and require views to be scaled up.
\begin{listing}[H]
  \caption{Rasterizing views}
  \begin{minted}{swift}
    self.view.layer.shouldRasterize = true
    self.view.layer.rasterizationScale = UIScreen.main.scale
  \end{minted}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Avoiding offscreen rendering % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Avoiding unnecessary offscreen rendering}
Offscreen rendering renders the required view into a new buffer (bitmap cache) which is offscreen (not on the screen) and then that buffer is drawn onto the screen. Compared to the conventional way of drawing the views piece by piece on the screen. For example, rasterization takes place offscreen as the view is composed into a bitmap and then the bitmap is drawn onto the screen.

Offscreen rendering is only beneficial to performance if the GPU can use the composed bitmap later on as well. This is only the case for  views containing static images and text. For views containing animated images, offscreen rendering would only add unnecessary strain on the GPU.

Layer rasterization was one way of manually triggering offscreen rendering. Offscreen rendering can also be triggered automatically by Core Animation. This would happen for example when a mask is directly or indirectly applied to a layer. That would force Core Animation to do offscreen rendering in order to apply that mask. This will in turn, as stated earlier, put unnecessary burden on the GPU.\cite{MovingPixelsOntoTheScreen}

In order to reap full benefits from rasterization of the layers, all other direct or indirect causes of offscreen rendering should be avoided. For example indirect causes for offscreen rendering are applying shadows and corner radiuses to the layer, the latter of which the test project does for all cells to create the chat bubble effect.\cite{MovingPixelsOntoTheScreen}

\subsubsection*{Theoretical benefits}
The main benefit for this is to avoid unnecessary work on the CPU and GPU when rendering views, which should lead to a much faster UI when scrolling. 

\subsubsection*{Performance changes}
Performance increase significantly!

\subsubsection*{Code examples}
In order to work around using CALayer's corner radius when drawing text cell views, the background with a corner radius could be drawn manually. This was achieved by creating a custom wrapper view for the text that knows how to draw the background efficiently. Below is the code for that view, which shows the background color being customizable and the draw method being only aware of drawing a rectangle with rounded corners.
\begin{listing}[H]
  \caption{Custom wrapper view for text message view with rounded corners that avoids offscreen rendering}
  \begin{minted}{swift}
    class NoOffscreenRendering_TextCell_LabelWrapView: UIView {
      private var _fillColor: UIColor?

      override init(frame: CGRect) {
        super.init(frame: frame)
        self.backgroundColor = Pairby.Colors.GRAY_BG
      }

      convenience init() {
        self.init(frame: CGRect.zero)
      }

      required init(coder aDecoder: NSCoder) {
        fatalError("This class does not support NSCoding")
      }

      func fillWith(color: UIColor) {
        self._fillColor = color
        self.setNeedsDisplay()
      }

      override func draw(_ rect: CGRect) {
        UIBezierPath(roundedRect: rect, cornerRadius: 15.0).addClip()
        self._fillColor?.setFill()
        UIBezierPath(rect: rect).fill()
      }
    }
  \end{minted}
\end{listing}


%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% AsyncDisplayKit % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ASyncDisplayKit}
AsyncDisplayKit is an iOS framework built on top of UIKit that keeps even the most complex user interfaces smooth and responsive.\cite{IntroducingAsyncDisplayKit} This library's goal was to make even the most complex views have a 60 frames per second performance in iOS applications by moving the rendering off the main threads.

In order to test this out, a best case scenario view was built, just like it was built with UIKit, but instead, AsyncDisplayKit's classes and methodologies were used.

\subsubsection*{Theoretical benefits}
The theoretical result for using ASyncDisplayKit would be the same as their purpose: providing the user with a smooth, constant 60 frames per second user interface.

\subsubsection*{Performance changes}
The performance for ASyncDisplayKit was very bad and comparably worse than that of iOS's built in UIKit's worst case scenario.

\subsubsection*{Code examples}
Below is a code example of how cells were created and returned to be used in the user interface, following AsyncDisplayKit's concentions.
\begin{listing}[H]
  \caption{Creating and using cells with AsyncDisplayKit's classes}
  \begin{minted}{swift}
    func tableNode(_ tableNode: ASTableNode, nodeBlockForRowAt indexPath: IndexPath) -> ASCellNodeBlock {
      let message = self._messages[indexPath.row]
      return {
        let cell = ASTextCellNode()
        cell.text = (message.message != nil) ? message.message! : "Media message with ID [\(message.id)]"
        return cell
      }
    }
  \end{minted}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% End result comparisons % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{End result}
\subsection{Compared to the best case scenario}

\subsection{Compared to the worst case scenario}

%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
% Conclusions % % REVIEWED | T:   | G:   %
%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Conclusions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% After-content sections %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%
% Figures %
%%%%%%%%%%%
\newpage
\phantomsection
\addcontentsline{toc}{section}{List of Figures}
\listoffigures

%%%%%%%%%%%%%%
% References %
%%%%%%%%%%%%%%
\newpage
\phantomsection
\addcontentsline{toc}{section}{References}
\bibliography{thesis}
\bibliographystyle{plain}

\end{document}
